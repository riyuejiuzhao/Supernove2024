# Supernove2024

2024年腾讯超新星比赛后台项目中期报告

## 题目分析
### 功能分析：
在多个微服务组成的游戏服务器中，为了支持有状态服务，同时也为了进行负载均衡，必然会需要对某个服务进行发现和路由转发的功能。本次超新星的
题目就是实现一个能够进行服务和路由管理的框架，它包含的基本功能如下：
1. 服务注册与反注册。一个服务启动时，将其注册到我们的服务器，可供其他服务实例获取；当它结束时，它可以将自己反注册，
从我们的服务器中删除。
2. 服务发现，根据筛选条件向客户端返回服务实例。服务发现功能在返回服务实例的时候需要考虑服务实例是否处在健康状态。
3. 健康监测，服务实例需要定期上报心跳，这样服务器会更新它的健康状态来确定服务是否还在线，是否还能正常访问。
4. 常规路由匹配规则，支持三个常规路由匹配规则。一致性哈希，随机路由匹配，基于权重的路由匹配。
5. 定义路由匹配规则，两种路由匹配规则，第一种是指定目标路由，指定目标路由可以将两个服务实例一一对应起来；
第二种是键值对路由，发送的信息中只要携带特定的key就会转发到特定的服务实例上。

我们需要提供一个基本SDK框架，使用户能够通过API接口方便快捷的使用我们的功能，SDK和服务器之间使用gRPC链接。项目功能结构图如下：

![项目功能图](./document/项目功能图.jpg#pic_center)

### 性能需求分析：
1. 自定义路由匹配规则需要支持千万级别的路由表，能够快速并且节约资源的情况下进行查找
2. 服务注册和服务发现功能需要支持上万服务实例，
3. 分析SDK性能占用。考虑到SDK会运行在服务实例上，为了避免影响服务实例的性能，应该尽可能使SDK轻量级，减少SDK的CPU时间和服务占用
4. 对路由规则进行压力测试，分析并验证性能是否符合要求

### 进阶需求分析：
1. 结合grpc实现
2. SideCar可以参考Istio实现

## 系统设计
在接下来，我们使用MiniRouter来命名我们设计的服务管理系统。

### 服务器设计
使用Redis保存数据,将MiniRouter分为3个微型服务器，结构如下图所示
![服务器设计](./document/服务器设计.png)

#### Discovery Svr
提供服务发现，路由发现的功能，根据SDK提供的服务名查询对应的数据并且下发给SDK。

Discovery Svr会在本地缓存一个版本的服务实例数据和路由数据。当需要下发数据的时候，先取Redis的版本号，然后判断与本地版本是否一致，
一致就不需要再从Redis中读取数据了，直接将本地缓存的数据下发。否则从Redis中读取数据再更新缓存，最后再下发。
通过缓冲区减小redis读写的压力。

#### Register Svr
提供服务注册，服务反注册，添加路由规则，删除路由规则的功能。

和Discovery Svr一样本地缓存了当前的数据，按照`map[服务名][实例ID]*实例信息`，`map[服务名][路由ID]*路由信息`的形式将其组织为字典结构，
方便快速查找服务/路由是否是已经注册过了。

#### Health Svr
提供心跳上报和健康信息获取的功能。

健康信息没有数据缓存和版本号，因为预计更新会非常频繁，没有缓存的必要性，
每次读写数据都会从redis中获取。当读写大量服务的健康数据时，为了优化数据传输效率，使用Pipeline来传递命令。

### redis数据设计

redis储存服务实例信息、健康信息、路由信息三种数据，
其中服务实例信息`ServiceInfo`和路由信息`ServiceRouterInfo`被protobuf打包为二进制格式储存.

**服务实例信息**：对于一个Service，我们在proto中定义了一个ServiceInfo，在redis中储存它的protobuf形式和Revision

| 资源   | redis类型 | key              | filed                | value   | 数据类型        |
|------|---------|------------------|----------------------|---------|-------------|
| 服务版本 | hash    | Hash.Service.服务名 | ServiceRevisionFiled | 版本号     | int64       |
| 服务信息 | hash    | Hash.Service.服务名 | ServiceInfoFiled     | 服务和实例数据 | ServiceInfo |

**健康信息**：redis储存方式如下，由于健康信息更新很频繁，往往几秒就要更新一次，每个实例更新的时间各有不同，
不适合将他们使用protobuf打包成二进制存放，也不适用版本号记录更新，所以将每个

| 资源     | redis类型 | key                  | filed         | value           |
|--------|---------|----------------------|---------------|-----------------|
| 健康数据   | hash    | Hash.Health.服务名.实例ID | TTL           | 超时上报间隔          |
| 健康数据   | hash    | Hash.Health.服务名.实例ID | LastHeartBeat | 最后一次上报的时间       |

**路由信息**：和服务实例信息储存的方式相似，

| 资源   | redis类型 | key             | filed               | value | 数据类型              |
|------|---------|-----------------|---------------------|-------|-------------------|
| 路由版本 | hash    | Hash.Router.服务名 | RouterRevisionFiled | 版本号   | int64             |
| 路由信息 | hash    | Hash.Router.服务名 | RouterInfoFiled     | 路由数据  | ServiceRouterInfo |


### 配置设计
配置文件要指明三个微务器集群的地址和其他配置

### SDK设计
使用grpc作为SDK和服务器通信的协议，因为服务器分为三个微服务
SDK也会分为三个部分，每个部分对应一个独立的微服务

#### 数据同步设计

第一次启动SDK的时候会自动拉去一次数据，之后定时触发，
根据配置中注册的本地数据更新任务，每过一段时间就自动拉取一次，

> 一开始设计的，配置文件中没有设置需要拉去的服务名，然后当用户GetInstances的时候，
> SDK检查本地是否有数据，如果没有就拉取对应的数据，
> 但是这个有一个问题，每次用户Get都有可能触发一次拉取，
> 这导致Get不能利用读写锁。
> 
> 我们设想一下这样一个场景，用户多线程调用GetInstance(ServiceA)，
> 查询时如果使用读锁，那么第一个请求和第二个请求同时查询，同时发现ServiceA不存在，
> 然后两个都请求写锁进行写入，一个先一个后会写入两次，
> 想要避免这个状况就必须在查询的时候使用写锁，这样只有一个会进行查询，但是这样做很明显不太符合
> SDK查多写少的情况，所以提前注册好需要拉取的服务

### 服务注册svr设计
服务发现每次增量更新后都需要重新写入redis中

### 服务发现svr设计
采用Redis云服务器作为数据库储存服务数据，
添加本地缓存的数据，主要数据在redis内储存，每过一段时间（可配置）就从redis中同步一次数据

### 健康检查svr设计

TTL，服务自己上报健康数据，健康检查服务器自动更新redis中的健康数据

### 动态路由svr设计
1. 一致性哈希
2. 随机
3. 基于权重
4. 指定目标
5. 键值对前缀匹配

### 路由策略和动态路由


## 项目结构

- miniRouterProto: sdk和svr通信所使用的grpc协议库
- sdk: 客户端所使用的sdk
- register-svr: 服务注册服务器

